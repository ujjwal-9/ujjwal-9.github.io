<!DOCTYPE html>
<html>
  <head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-70SVKC0TJP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-70SVKC0TJP');
  </script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ujjwal Upadhyay - Docker Overview</title>
  <meta name="description" content="Docker Website!Checkout my project code @ GithubAbstractWe often try to simplify things but usually end up making it much more difficult. Similar is the case...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="stylesheet" type="text/css" href="/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/css/icomoon.css">
  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->

  <link rel="canonical" href="/articles/20/docker">

  <link rel="alternate" type="application/rss+xml" title="Ujjwal Upadhyay" href="/feed.xml" />
  <link rel="icon" type="image/svg" href="/assets/img/infinite.svg">
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Docker Overview" />
<meta name="author" content="Ujjwal Upadhyay" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Docker Website! Checkout my project code @ Github Abstract We often try to simplify things but usually end up making it much more difficult. Similar is the case with code. We code, install additional dependencies, and remove redundancies. With this 3 step process, we sometimes end up with very difficult process to explain on how to reproduce the results and rerun the experiments. This blog explains about docker which is a tool designed to make it easier to create, deploy, and run applications by using containers. Earlier Work Before docker was introduced, virtualization of resources was used which provided independent virtual machines for clients to work upon. But this came with a price of heavy operating systems which may easily exceed over 1GB despite supporting light applications (like 300MB). So, this drawback led to advent of containers (dockers). Docker and Virtual Machine Architecture What is docker? Docker is based on containers which run on shared resources of your PC but in isolation as shown in the following architecture. Container is an efficient mechanism to keep your software components together and maintainable. You can also run multiple containers at the same time to support a serive. Docker also provides with a mechanism to start all the containers concerned with that service with one command using docker compose. We will talk about it later. Dockerfile A Dockerfile is a simple text file that contains a list of commands that the Docker client calls while creating an image. Working Dockerfile for conda environemnt. FROM continuumio/miniconda3 WORKDIR /app # Create the environment: COPY environment.yml . RUN conda env create -f environment.yml # Make RUN commands use the new environment: SHELL [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;/bin/bash&quot;, &quot;-c&quot;] RUN python -c &quot;import numpy&quot; # The code to run when container is started: COPY run.py . ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;python&quot;, &quot;run.py&quot;] FROM creates a layer from the continuumio/miniconda3 Docker image. COPY adds files from your Docker client’s current directory. RUN builds your application with make. CMD specifies what command to run within the container. ENTRYPOINT is to set the image’s main command, allowing that image to be run as though it was that command. SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is [&quot;/bin/sh&quot;, &quot;-c&quot;], and on Windows is [&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;] Container Image is built using $ docker build -t &lt;app_name&gt;:&lt;label_name&gt; . To make sure certain package is installed we can add, RUN echo &quot;Make sure flask is installed:&quot; RUN python -c &quot;import flask&quot; The image defined by your Dockerfile generate containers that have ephemeral states. It gets destroyed as soon as process is over. To access files in container we may either bash into container to run the command which generates a new file which we need on our local file system and then use $docker cp to tranfer to local file system. And if we wish to use files from our local system in docker container we may mount those files either using COPY when generating container or we may mount it at runtime using volume. We can also specify volume which can be utilized by both local file system and docker. $ docker build -t dockerized-run . $ docker run --rm -it -v &lt;PATH-TO_IMAGES&gt;/images:/app/images --entrypoint=/bin/bash dockerized-run (base) root@b74706db6f68:/app# ls environment.yml images (base) root@b74706db6f68:/app# cd images (base) root@b74706db6f68:/app/images# ls out.png test.png Volume Mounting volume at runtime. $ docker run --rm -it -v &lt;source-path&gt;:&lt;target-path&gt; &lt;docker-container-name&gt; The above command will run docker with specified volume (-v) mounted in the Mounting volume at build time using docker compose. version: &quot;3.9&quot; services: deeplearning: build: . volumes: - ./images:/app/images Here volume keyword specifies to mount current directory on local file system to /images on container. So the changes made to those files mounted at /images will also be reflected in local file system. Docker Compose It is used to start multiple containers as a single service. You may start services like react and flask server together as a service. version: &quot;3.9&quot; services: web: build: . ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; Taken from docker compose example at docker compose docs. Here we are starting 2 services web and redis. Web is build using dockerfile as specified by . (dot) pointing towards dockerfile and port binds the container and the host machine to the exposed port, 5000. This can also be done using dockerfile by using EXPOSE. version is used to specify that we want the details of the version of Docker Compose. Application Lets also talk about dockers application in AI research. Now given todays deep learning systems and its other applications, the need for using sameversion of library becomes necessary for inducing reproducibilty in these models. The most common package manager used for python is anaconda. name: myenv channels: - conda-forge dependencies: - python=3.8 - numpy We build it with below specified dockerfile. FROM continuumio/miniconda3 COPY environment.yml . RUN conda env create -f environment.yml ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;example&quot;, \ &quot;python&quot;, &quot;-c&quot;, \ &quot;import numpy; print(&#39;success!&#39;)&quot;] In this environment, we install Python 3.8 and NumPy, and when we run the image it imports NumPy to make sure everything is working. This can bloat upto 950MB. Where is all the disk space being going? Conda caches downloaded packages. Conda base environment where toolchain is installed takes huge space. For example, when we install continuumio/miniconda3, it comes with its own python which we dont intend use. First problem can be solved by removing those cached files. Second problem is conda specific and hence unavoidable but we can do away with it at runtime. # The build-stage image: FROM continuumio/miniconda3 AS build # Install the package as normal: COPY environment.yml . RUN conda env create -f environment.yml # Install conda-pack: RUN conda install -c conda-forge conda-pack # Use conda-pack to create a standalone enviornment # in /venv: RUN conda-pack -n example -o /tmp/env.tar &amp;&amp; \ mkdir /venv &amp;&amp; cd /venv &amp;&amp; tar xf /tmp/env.tar &amp;&amp; \ rm /tmp/env.tar # We&#39;ve put venv in same path it&#39;ll be in final image, # so now fix up paths: RUN /venv/bin/conda-unpack # The runtime-stage image; we can use Debian as the # base image since the Conda env also includes Python # for us. FROM debian:buster AS runtime # Copy /venv from the previous stage: COPY --from=build /venv /venv # When image is run, run the code with the environment # activated: SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;] ENTRYPOINT source /venv/bin/activate &amp;&amp; \ python -c &quot;import numpy; print(&#39;success!&#39;)&quot; The above solutions is provided here. Follow me on twitter @theujjwal9" />
<meta property="og:description" content="Docker Website! Checkout my project code @ Github Abstract We often try to simplify things but usually end up making it much more difficult. Similar is the case with code. We code, install additional dependencies, and remove redundancies. With this 3 step process, we sometimes end up with very difficult process to explain on how to reproduce the results and rerun the experiments. This blog explains about docker which is a tool designed to make it easier to create, deploy, and run applications by using containers. Earlier Work Before docker was introduced, virtualization of resources was used which provided independent virtual machines for clients to work upon. But this came with a price of heavy operating systems which may easily exceed over 1GB despite supporting light applications (like 300MB). So, this drawback led to advent of containers (dockers). Docker and Virtual Machine Architecture What is docker? Docker is based on containers which run on shared resources of your PC but in isolation as shown in the following architecture. Container is an efficient mechanism to keep your software components together and maintainable. You can also run multiple containers at the same time to support a serive. Docker also provides with a mechanism to start all the containers concerned with that service with one command using docker compose. We will talk about it later. Dockerfile A Dockerfile is a simple text file that contains a list of commands that the Docker client calls while creating an image. Working Dockerfile for conda environemnt. FROM continuumio/miniconda3 WORKDIR /app # Create the environment: COPY environment.yml . RUN conda env create -f environment.yml # Make RUN commands use the new environment: SHELL [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;/bin/bash&quot;, &quot;-c&quot;] RUN python -c &quot;import numpy&quot; # The code to run when container is started: COPY run.py . ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;python&quot;, &quot;run.py&quot;] FROM creates a layer from the continuumio/miniconda3 Docker image. COPY adds files from your Docker client’s current directory. RUN builds your application with make. CMD specifies what command to run within the container. ENTRYPOINT is to set the image’s main command, allowing that image to be run as though it was that command. SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is [&quot;/bin/sh&quot;, &quot;-c&quot;], and on Windows is [&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;] Container Image is built using $ docker build -t &lt;app_name&gt;:&lt;label_name&gt; . To make sure certain package is installed we can add, RUN echo &quot;Make sure flask is installed:&quot; RUN python -c &quot;import flask&quot; The image defined by your Dockerfile generate containers that have ephemeral states. It gets destroyed as soon as process is over. To access files in container we may either bash into container to run the command which generates a new file which we need on our local file system and then use $docker cp to tranfer to local file system. And if we wish to use files from our local system in docker container we may mount those files either using COPY when generating container or we may mount it at runtime using volume. We can also specify volume which can be utilized by both local file system and docker. $ docker build -t dockerized-run . $ docker run --rm -it -v &lt;PATH-TO_IMAGES&gt;/images:/app/images --entrypoint=/bin/bash dockerized-run (base) root@b74706db6f68:/app# ls environment.yml images (base) root@b74706db6f68:/app# cd images (base) root@b74706db6f68:/app/images# ls out.png test.png Volume Mounting volume at runtime. $ docker run --rm -it -v &lt;source-path&gt;:&lt;target-path&gt; &lt;docker-container-name&gt; The above command will run docker with specified volume (-v) mounted in the Mounting volume at build time using docker compose. version: &quot;3.9&quot; services: deeplearning: build: . volumes: - ./images:/app/images Here volume keyword specifies to mount current directory on local file system to /images on container. So the changes made to those files mounted at /images will also be reflected in local file system. Docker Compose It is used to start multiple containers as a single service. You may start services like react and flask server together as a service. version: &quot;3.9&quot; services: web: build: . ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; Taken from docker compose example at docker compose docs. Here we are starting 2 services web and redis. Web is build using dockerfile as specified by . (dot) pointing towards dockerfile and port binds the container and the host machine to the exposed port, 5000. This can also be done using dockerfile by using EXPOSE. version is used to specify that we want the details of the version of Docker Compose. Application Lets also talk about dockers application in AI research. Now given todays deep learning systems and its other applications, the need for using sameversion of library becomes necessary for inducing reproducibilty in these models. The most common package manager used for python is anaconda. name: myenv channels: - conda-forge dependencies: - python=3.8 - numpy We build it with below specified dockerfile. FROM continuumio/miniconda3 COPY environment.yml . RUN conda env create -f environment.yml ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;example&quot;, \ &quot;python&quot;, &quot;-c&quot;, \ &quot;import numpy; print(&#39;success!&#39;)&quot;] In this environment, we install Python 3.8 and NumPy, and when we run the image it imports NumPy to make sure everything is working. This can bloat upto 950MB. Where is all the disk space being going? Conda caches downloaded packages. Conda base environment where toolchain is installed takes huge space. For example, when we install continuumio/miniconda3, it comes with its own python which we dont intend use. First problem can be solved by removing those cached files. Second problem is conda specific and hence unavoidable but we can do away with it at runtime. # The build-stage image: FROM continuumio/miniconda3 AS build # Install the package as normal: COPY environment.yml . RUN conda env create -f environment.yml # Install conda-pack: RUN conda install -c conda-forge conda-pack # Use conda-pack to create a standalone enviornment # in /venv: RUN conda-pack -n example -o /tmp/env.tar &amp;&amp; \ mkdir /venv &amp;&amp; cd /venv &amp;&amp; tar xf /tmp/env.tar &amp;&amp; \ rm /tmp/env.tar # We&#39;ve put venv in same path it&#39;ll be in final image, # so now fix up paths: RUN /venv/bin/conda-unpack # The runtime-stage image; we can use Debian as the # base image since the Conda env also includes Python # for us. FROM debian:buster AS runtime # Copy /venv from the previous stage: COPY --from=build /venv /venv # When image is run, run the code with the environment # activated: SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;] ENTRYPOINT source /venv/bin/activate &amp;&amp; \ python -c &quot;import numpy; print(&#39;success!&#39;)&quot; The above solutions is provided here. Follow me on twitter @theujjwal9" />
<meta property="og:site_name" content="Ujjwal Upadhyay" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-24T00:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Docker Overview" />
<script type="application/ld+json">
{"url":"/articles/20/docker","headline":"Docker Overview","dateModified":"2020-12-24T00:00:00-06:00","datePublished":"2020-12-24T00:00:00-06:00","author":{"@type":"Person","name":"Ujjwal Upadhyay"},"mainEntityOfPage":{"@type":"WebPage","@id":"/articles/20/docker"},"description":"Docker Website! Checkout my project code @ Github Abstract We often try to simplify things but usually end up making it much more difficult. Similar is the case with code. We code, install additional dependencies, and remove redundancies. With this 3 step process, we sometimes end up with very difficult process to explain on how to reproduce the results and rerun the experiments. This blog explains about docker which is a tool designed to make it easier to create, deploy, and run applications by using containers. Earlier Work Before docker was introduced, virtualization of resources was used which provided independent virtual machines for clients to work upon. But this came with a price of heavy operating systems which may easily exceed over 1GB despite supporting light applications (like 300MB). So, this drawback led to advent of containers (dockers). Docker and Virtual Machine Architecture What is docker? Docker is based on containers which run on shared resources of your PC but in isolation as shown in the following architecture. Container is an efficient mechanism to keep your software components together and maintainable. You can also run multiple containers at the same time to support a serive. Docker also provides with a mechanism to start all the containers concerned with that service with one command using docker compose. We will talk about it later. Dockerfile A Dockerfile is a simple text file that contains a list of commands that the Docker client calls while creating an image. Working Dockerfile for conda environemnt. FROM continuumio/miniconda3 WORKDIR /app # Create the environment: COPY environment.yml . RUN conda env create -f environment.yml # Make RUN commands use the new environment: SHELL [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;/bin/bash&quot;, &quot;-c&quot;] RUN python -c &quot;import numpy&quot; # The code to run when container is started: COPY run.py . ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;myenv&quot;, &quot;python&quot;, &quot;run.py&quot;] FROM creates a layer from the continuumio/miniconda3 Docker image. COPY adds files from your Docker client’s current directory. RUN builds your application with make. CMD specifies what command to run within the container. ENTRYPOINT is to set the image’s main command, allowing that image to be run as though it was that command. SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is [&quot;/bin/sh&quot;, &quot;-c&quot;], and on Windows is [&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;] Container Image is built using $ docker build -t &lt;app_name&gt;:&lt;label_name&gt; . To make sure certain package is installed we can add, RUN echo &quot;Make sure flask is installed:&quot; RUN python -c &quot;import flask&quot; The image defined by your Dockerfile generate containers that have ephemeral states. It gets destroyed as soon as process is over. To access files in container we may either bash into container to run the command which generates a new file which we need on our local file system and then use $docker cp to tranfer to local file system. And if we wish to use files from our local system in docker container we may mount those files either using COPY when generating container or we may mount it at runtime using volume. We can also specify volume which can be utilized by both local file system and docker. $ docker build -t dockerized-run . $ docker run --rm -it -v &lt;PATH-TO_IMAGES&gt;/images:/app/images --entrypoint=/bin/bash dockerized-run (base) root@b74706db6f68:/app# ls environment.yml images (base) root@b74706db6f68:/app# cd images (base) root@b74706db6f68:/app/images# ls out.png test.png Volume Mounting volume at runtime. $ docker run --rm -it -v &lt;source-path&gt;:&lt;target-path&gt; &lt;docker-container-name&gt; The above command will run docker with specified volume (-v) mounted in the Mounting volume at build time using docker compose. version: &quot;3.9&quot; services: deeplearning: build: . volumes: - ./images:/app/images Here volume keyword specifies to mount current directory on local file system to /images on container. So the changes made to those files mounted at /images will also be reflected in local file system. Docker Compose It is used to start multiple containers as a single service. You may start services like react and flask server together as a service. version: &quot;3.9&quot; services: web: build: . ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; Taken from docker compose example at docker compose docs. Here we are starting 2 services web and redis. Web is build using dockerfile as specified by . (dot) pointing towards dockerfile and port binds the container and the host machine to the exposed port, 5000. This can also be done using dockerfile by using EXPOSE. version is used to specify that we want the details of the version of Docker Compose. Application Lets also talk about dockers application in AI research. Now given todays deep learning systems and its other applications, the need for using sameversion of library becomes necessary for inducing reproducibilty in these models. The most common package manager used for python is anaconda. name: myenv channels: - conda-forge dependencies: - python=3.8 - numpy We build it with below specified dockerfile. FROM continuumio/miniconda3 COPY environment.yml . RUN conda env create -f environment.yml ENTRYPOINT [&quot;conda&quot;, &quot;run&quot;, &quot;-n&quot;, &quot;example&quot;, \\ &quot;python&quot;, &quot;-c&quot;, \\ &quot;import numpy; print(&#39;success!&#39;)&quot;] In this environment, we install Python 3.8 and NumPy, and when we run the image it imports NumPy to make sure everything is working. This can bloat upto 950MB. Where is all the disk space being going? Conda caches downloaded packages. Conda base environment where toolchain is installed takes huge space. For example, when we install continuumio/miniconda3, it comes with its own python which we dont intend use. First problem can be solved by removing those cached files. Second problem is conda specific and hence unavoidable but we can do away with it at runtime. # The build-stage image: FROM continuumio/miniconda3 AS build # Install the package as normal: COPY environment.yml . RUN conda env create -f environment.yml # Install conda-pack: RUN conda install -c conda-forge conda-pack # Use conda-pack to create a standalone enviornment # in /venv: RUN conda-pack -n example -o /tmp/env.tar &amp;&amp; \\ mkdir /venv &amp;&amp; cd /venv &amp;&amp; tar xf /tmp/env.tar &amp;&amp; \\ rm /tmp/env.tar # We&#39;ve put venv in same path it&#39;ll be in final image, # so now fix up paths: RUN /venv/bin/conda-unpack # The runtime-stage image; we can use Debian as the # base image since the Conda env also includes Python # for us. FROM debian:buster AS runtime # Copy /venv from the previous stage: COPY --from=build /venv /venv # When image is run, run the code with the environment # activated: SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;] ENTRYPOINT source /venv/bin/activate &amp;&amp; \\ python -c &quot;import numpy; print(&#39;success!&#39;)&quot; The above solutions is provided here. Follow me on twitter @theujjwal9","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  

  

  

  
  <meta content="assets/img/docker/docker.png" property="og:image">
  
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
        <ul class="topnav" style="float:left">
            <li><a style="padding-top:.5em" href="/"><strong>Ujjwal Upadhyay</strong></a></li>
        </ul>
	<ul class="topnav">    
        
	
            
            
            
  	
            
            
	        
                <li><a class="right" href="/research">Research</a></li>
	        
	    
            
  	
            
            
	        
                <li><a class="right" href="/writings">Writings</a></li>
	        
	    
            
  	
            
            
            
  	
            
  	
            
  	
            
  	
        <li><a class="right" href="https://drive.google.com/file/d/13Hxj3cRTK9nMl54z58sPOoOah6iEtw-C/view?usp=sharing">cv</a></li>
	</ul>
	</nav>
        <hr class="slender">
</header>

    <article class="group">
      <h1 style="font-style:normal; font-size:3rem; font-weight: 500;">Docker Overview</h1>
<p class="subtitle">December 24, 2020</p>

<p><a href="https://docker.com/">Docker Website!</a></p>

<p>Checkout my project code @ <a href="https://github.com/Ujjwal-9/medical-training/tree/master/dockerized-run">Github</a></p>

<h1 id="abstract">Abstract</h1>
<p>We often try to simplify things but usually end up making it much more difficult. Similar is the case with code. We code, install additional dependencies, and remove redundancies. With this 3 step process, we sometimes end up with very difficult process to explain on how to reproduce the results and rerun the experiments. This blog explains about docker which is a tool designed to make it easier to create, deploy, and run applications by using containers.</p>

<h1 id="earlier-work">Earlier Work</h1>
<p>Before docker was introduced, virtualization of resources was used which provided independent virtual machines for clients to work upon. But this came with a price of heavy operating systems which may easily exceed over <em>1GB</em> despite supporting light applications (like 300MB). So, this drawback led to advent of containers (dockers).</p>

<figure>
  <img src="/assets/img/docker/docker-vs-vm.png" width="600" style="margin-top: 2rem;" />
  <figcaption style="margin-top: 2rem;">Docker and Virtual Machine Architecture</figcaption>
</figure>

<h1 id="what-is-docker">What is docker?</h1>
<p>Docker is based on containers which run on shared resources of your PC but in isolation as shown in the following architecture. Container is an efficient mechanism to keep your software components together and maintainable. You can also run multiple containers at the same time to support a serive. Docker also provides with a mechanism to start all the containers concerned with that service with one command using docker compose. We will talk about it later.</p>

<h1 id="dockerfile">Dockerfile</h1>

<p>A Dockerfile is a simple text file that contains a list of commands that the Docker client calls while creating an image.</p>

<p>Working Dockerfile for conda environemnt.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> continuumio/miniconda3</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Create the environment:</span>
<span class="k">COPY</span><span class="s"> environment.yml .</span>
<span class="k">RUN </span>conda <span class="nb">env </span>create <span class="nt">-f</span> environment.yml

<span class="c"># Make RUN commands use the new environment:</span>
<span class="k">SHELL</span><span class="s"> ["conda", "run", "-n", "myenv", "/bin/bash", "-c"]</span>
<span class="k">RUN </span>python <span class="nt">-c</span> <span class="s2">"import numpy"</span>

<span class="c"># The code to run when container is started:</span>
<span class="k">COPY</span><span class="s"> run.py .</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["conda", "run", "-n", "myenv", "python", "run.py"]</span>
</code></pre></div></div>

<ul>
<li>FROM creates a layer from the continuumio/miniconda3 Docker image.</li>
<li>COPY adds files from your Docker client’s current directory.</li>
<li>RUN builds your application with make.</li>
<li>CMD specifies what command to run within the container.</li>
<li>ENTRYPOINT is to set the image’s main command, allowing that image to be run as though it was that command.</li>
<li>SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is ["/bin/sh", "-c"], and on Windows is ["cmd", "/S", "/C"]</li>
</ul>

<!-- 1. FROM creates a layer from the continuumio/miniconda3 Docker image.

2. COPY adds files from your Docker client’s current directory.

3. RUN builds your application with make.

4. CMD specifies what command to run within the container.

5. ENTRYPOINT is to set the image’s main command, allowing that image to be run as though it was that command.

6. SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is `["/bin/sh", "-c"]`, and on Windows is `["cmd", "/S", "/C"]` -->

<p>Container Image is built using</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> &lt;app_name&gt;:&lt;label_name&gt; <span class="nb">.</span>
</code></pre></div></div>

<p>To make sure certain package is installed we can add,</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span><span class="nb">echo</span> <span class="s2">"Make sure flask is installed:"</span>
<span class="k">RUN </span>python <span class="nt">-c</span> <span class="s2">"import flask"</span>
</code></pre></div></div>

<p>The image defined by your Dockerfile generate containers that have <strong>ephemeral</strong> states. It gets destroyed as soon as process is over. To access files in container we may either bash into container to run the command which generates a new file which we need on our local file system and then use <code class="language-plaintext highlighter-rouge">$docker cp</code> to tranfer to local file system. And if we wish to use files from our local system in docker container we may mount those files either using <code class="language-plaintext highlighter-rouge">COPY</code> when generating container or we may mount it at runtime using volume. We can also specify volume which can be utilized by both local file system and docker.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> dockerized-run <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> &lt;PATH-TO_IMAGES&gt;/images:/app/images <span class="nt">--entrypoint</span><span class="o">=</span>/bin/bash dockerized-run

<span class="o">(</span>base<span class="o">)</span> root@b74706db6f68:/app# <span class="nb">ls
</span>environment.yml  images
<span class="o">(</span>base<span class="o">)</span> root@b74706db6f68:/app# <span class="nb">cd </span>images
<span class="o">(</span>base<span class="o">)</span> root@b74706db6f68:/app/images# <span class="nb">ls
</span>out.png  test.png
</code></pre></div></div>

<h2 id="volume">Volume</h2>

<ul>
  <li>Mounting volume at runtime.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> &lt;source-path&gt;:&lt;target-path&gt; &lt;docker-container-name&gt;
</code></pre></div></div>

<p>The above command will run docker with specified volume (-v) mounted in the</p>

<ul>
  <li>Mounting volume at build time using docker compose.</li>
</ul>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.9"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">deeplearning</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./images:/app/images</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">volume</code> keyword specifies to mount current directory on local file system to /images on container. So the changes made to those files mounted at /images will also be reflected in local file system.</p>

<h1 id="docker-compose">Docker Compose</h1>

<p>It is used to start multiple containers as a single service. You may start services like react and flask server together as a service.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.9"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:5000"</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s2">"</span><span class="s">redis:alpine"</span>
</code></pre></div></div>
<p>Taken from docker compose example at <a href="https://docs.docker.com/compose/gettingstarted/">docker compose docs</a>. Here we are starting 2 services 	web and redis. <code class="language-plaintext highlighter-rouge">Web</code> is build using dockerfile as specified by <code class="language-plaintext highlighter-rouge">. (dot)</code> pointing towards dockerfile and <code class="language-plaintext highlighter-rouge">port</code> binds the container and the host machine to the exposed port, 5000. This can also be done using dockerfile by using <code class="language-plaintext highlighter-rouge">EXPOSE</code>.</p>

<p><code class="language-plaintext highlighter-rouge">version</code> is used to specify that we want the details of the version of Docker Compose.</p>

<h1 id="application">Application</h1>
<p>Lets also talk about dockers application in AI research. Now given todays deep learning systems and its other applications, the need for using sameversion of library becomes necessary for inducing reproducibilty in these models. The most common package manager used for python is anaconda.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">myenv</span>
<span class="na">channels</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">conda-forge</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">python=3.8</span>
  <span class="pi">-</span> <span class="s">numpy</span>
</code></pre></div></div>

<p>We build it with below specified dockerfile.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> continuumio/miniconda3</span>

<span class="k">COPY</span><span class="s"> environment.yml .</span>
<span class="k">RUN </span>conda <span class="nb">env </span>create <span class="nt">-f</span> environment.yml

<span class="k">ENTRYPOINT</span><span class="s"> ["conda", "run", "-n", "example", \</span>
            "python", "-c", \
            "import numpy; print('success!')"]
</code></pre></div></div>

<p>In this environment, we install Python 3.8 and NumPy, and when we run the image it imports NumPy to make sure everything is working. This can bloat upto <em>950MB</em>. Where is all the disk space being going?</p>

<ol>
  <li>Conda caches downloaded packages.</li>
  <li>Conda base environment where toolchain is installed takes huge space. For example, when we install <code class="language-plaintext highlighter-rouge">continuumio/miniconda3</code>, it comes with its own python which we dont intend use.</li>
</ol>

<p>First problem can be solved by removing those cached files. Second problem is conda specific and hence unavoidable but we can do away with it at runtime.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The build-stage image:</span>
<span class="k">FROM</span><span class="s"> continuumio/miniconda3 AS build</span>

<span class="c"># Install the package as normal:</span>
<span class="k">COPY</span><span class="s"> environment.yml .</span>
<span class="k">RUN </span>conda <span class="nb">env </span>create <span class="nt">-f</span> environment.yml

<span class="c"># Install conda-pack:</span>
<span class="k">RUN </span>conda <span class="nb">install</span> <span class="nt">-c</span> conda-forge conda-pack

<span class="c"># Use conda-pack to create a standalone enviornment</span>
<span class="c"># in /venv:</span>
<span class="k">RUN </span>conda-pack <span class="nt">-n</span> example <span class="nt">-o</span> /tmp/env.tar <span class="o">&amp;&amp;</span> <span class="se">\
</span>  <span class="nb">mkdir</span> /venv <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /venv <span class="o">&amp;&amp;</span> <span class="nb">tar </span>xf /tmp/env.tar <span class="o">&amp;&amp;</span> <span class="se">\
</span>  <span class="nb">rm</span> /tmp/env.tar

<span class="c"># We've put venv in same path it'll be in final image,</span>
<span class="c"># so now fix up paths:</span>
<span class="k">RUN </span>/venv/bin/conda-unpack


<span class="c"># The runtime-stage image; we can use Debian as the</span>
<span class="c"># base image since the Conda env also includes Python</span>
<span class="c"># for us.</span>
<span class="k">FROM</span><span class="s"> debian:buster AS runtime</span>

<span class="c"># Copy /venv from the previous stage:</span>
<span class="k">COPY</span><span class="s"> --from=build /venv /venv</span>

<span class="c"># When image is run, run the code with the environment</span>
<span class="c"># activated:</span>
<span class="k">SHELL</span><span class="s"> ["/bin/bash", "-c"]</span>
<span class="k">ENTRYPOINT</span><span class="s"> source /venv/bin/activate &amp;&amp; \</span>
           python -c "import numpy; print('success!')"
</code></pre></div></div>
<p>The above solutions is provided <a href="https://pythonspeed.com/articles/conda-docker-image-size/">here</a>.</p>

<blockquote>
  <p><strong>Follow me on twitter <a href="https://twitter.com/theujjwal9">@theujjwal9</a></strong></p>
</blockquote>



    </article>
    <span class="print-footer">Docker Overview - December 24, 2020 - Ujjwal Upadhyay</span>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
<!-- <style>

i:hover{
  -webkit-animation: glow 2s ease-in-out infinite alternate;
  -moz-animation: glow 2s ease-in-out infinite alternate;
  animation: glow 2s ease-in-out infinite alternate;
}

@-webkit-keyframes glow {
  from {
    text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #e60073, 0 0 40px #e60073, 0 0 50px #e60073, 0 0 60px #e60073, 0 0 70px #e60073;
  }
  
  to {
    text-shadow: 0 0 20px #fff, 0 0 30px #ff4da6, 0 0 40px #ff4da6, 0 0 50px #ff4da6, 0 0 60px #ff4da6, 0 0 70px #ff4da6, 0 0 80px #ff4da6;
  }

</style> -->

<footer>
  <hr class="slender">
  <ul class="footer-links" style="font-size: 1.6rem;">
    <li><a href="mailto:ujjwalupadhyay8@gmail.com"><i class="fa fa-envelope"></i></a></li>
    <li><a href="https://twitter.com/theujjwal9"><i class="fa fa-twitter"></i></a></li>
    <li><a href="https://github.com/ujjwal-9"><i class="fa fa-github"></i></a></li>
    <li><a href="https://www.linkedin.com/in/ujjwal-9/"><i class="fa fa-linkedin"></i></a></li>
    <li><a href="https://scholar.google.com/citations?user=lvpaXdEAAAAJ&hl=en"><i class="fa fa-graduation-cap"></i></a></li>
    <li><a href="https://ujjwal-9.github.io/feed.xml"><i class="fa fa-rss"></i></a></li>
    <!-- 
      <li>
        <a href="https://github.com/ujjwal-9"><span class="icon-github"></span></a>
      </li>
    
      <li>
        <a href="https://linkedin.com/in/ujjwal-9"><span class="icon-linkedin"></span></a>
      </li>
    
      <li>
        <a href="/feed.xml"><span class="icon-rss2"></span></a>
      </li>
       -->
  </ul>
<div class="credits">
<span>&copy; 2024 &nbsp;&nbsp;UJJWAL UPADHYAY</span></br> <br>
</div>  
</footer>
  </body>
</html>
